/*
 * Keccak-f implementation in Cryptol
 * 
 * Copyright (c) 2010 - Alfonso De Gregorio adg@crypto.lo.gy
 *
 * run with: KeccakRound(State, Rounds)
 * example:  KeccakRound(A, nrRounds - 1)
 *
 */

include "mmult.cry";

type nrWords  = 25;
nrRounds  = 24;

repl (xs, i, y) = [| if k == i then y else x
                  || k <- [0.. (width xs)]
                  || x <- xs
                  |];

/* A possible state, for testing purposes */
A : [5][5][8][8];
A = [[[0xe7 0xdd 0xe1 0x40 0x79 0x8f 0x25 0xf1]
  [0xd4 0x6f 0x8e 0x7f 0x2d 0xa4 0x97 0xff]
  [0x35 0xd6 0x17 0x23 0x3f 0xa9 0x5a 0xeb]
  [0x61 0xae 0xd9 0x21 0x5a 0x63 0xe5 0x05]
  [0x14 0x26 0x3a 0xae 0x22 0x79 0x0c 0x94]]
 [[0x8a 0x47 0xc0 0x33 0xf9 0xcc 0xd5 0x84]
  [0xc4 0x47 0x46 0xa4 0xa0 0xe5 0xfe 0x90]
  [0x03 0x21 0x71 0x0d 0x26 0xe6 0xa6 0xa9]
  [0xf2 0x70 0xc9 0x8c 0xf2 0xfe 0xbe 0x64]
  [0xe4 0x09 0xc5 0xa2 0x24 0xf9 0x41 0x18]]
 [[0xee 0xa9 0x5a 0xa6 0x1e 0x26 0x98 0xd5]
  [0x76 0x2e 0x19 0xd6 0x0c 0xda 0x5b 0x8c]
  [0x5f 0x55 0xcf 0xdb 0x16 0x7c 0xa5 0x81]
  [0x11 0x66 0xc4 0x7b 0x95 0x70 0x36 0x61]
  [0xc2 0x65 0x04 0xe7 0x26 0x35 0xf5 0x16]]
 [[0x4d 0x49 0x80 0x6f 0x30 0x47 0x15 0xbd]
  [0x9c 0x05 0x19 0x1b 0xf7 0xa6 0x30 0xad]
  [0x26 0xc8 0x47 0x03 0xcd 0x31 0xb8 0x43]
  [0xcb 0x0e 0xd0 0x4f 0x55 0x5a 0x7c 0xb8]
  [0x3b 0xa1 0x30 0x7f 0xe9 0x44 0xf6 0x75]]
 [[0x57 0xd0 0x53 0x62 0x05 0x4e 0x28 0x8b]
  [0x64 0xfc 0x8f 0xd0 0xb7 0x5a 0x93 0x30]
  [0x9f 0x56 0xa5 0x11 0x1a 0x2f 0xf2 0x01]
  [0xc8 0x32 0xcf 0x1c 0x8a 0xe8 0x3e 0x8c]
  [0x49 0xa2 0xec 0x5c 0x7b 0xff 0xf1 0xea]]];


thetaT : [5][5][8][8] -> [5][5][8][8];
thetaT (tA) = A'
  where {

  /* Theta */
  A = transpose(tA);

  /* 
   * Over higher-dimensional sequences the exclusive-or operates 
   * element-wise. Here the innermost elements are lanes. They are 
   * processed in sheets by accessing the permutation state array 
   * via the index operator.
   */
   C = (A @ 0) ^ (A @ 1) ^ (A @ 2) ^ (A @ 3) ^ (A @ 4);    

  /* Rotate left by 1 each lane in C */
  D = [] # [| splitBy(8, join(C @ x) <<< 1)
           || x <- [0..4]
           |];

  /* The pivot needs explicit typing, otherwise some index evaluations
   * would fail. For instance, x + 4 % 5 = 0, where x is 4 */
  A' = [| [| (A @ y @ x) ^ 
             (D @ (((x : [8]) + 1) % 5)) ^ 
             (C @ (((x : [8]) + 4) % 5))
          || y  <- [0..4] 
          |]
       || x <- [0..4]
       |];

  };


/* LFSR implementation */
nextShiftIndex : [2][1][16] -> [2][1][16];
nextShiftIndex(prevIndex) = [[x] [y]] 
  where {
     [[a] [b]] = mmult([[0 1][2 3]], prevIndex);
     x = a % 5; y = b % 5;
  };

nextPiIndex : [2][1][16] -> [2][1][16];
nextPiIndex(prevIndex) = [[x] [y]] 
  where {
     [[a] [b]] = mmult([[3 (-1)][(-2) 0]], prevIndex);
     x = a % 5; y = b % 5;
  };


iterateShiftIndex : [2][1][16] -> [24][2][1][16];
iterateShiftIndex x = outs
  where outs = [x] # [| nextShiftIndex prev
                     || i <- [0..22]
                     || prev <- outs
                     |];

/* iterateLFSR : {a}(fin a) => [9] -> [169]LFSRState; */
iterateLFSR(x) = nr
  where {
        outs = [ {state = x; result = True; }  ] # 
                     [|  LFSR86540(((prev) : LFSRState ).state) 

                     || i <- [0..23], j <- [0..6]
                     || prev <- outs
                     |];

        nr = drop(1, outs);
  };



rho : [5][5][8][8] -> [5][5][8][8];
rho (A) = A'
  where {
    A' = [| [| splitBy(8, join(A @ x @ y) <<< (KeccakRhoOffsets @ x @ y))
            || y <- [0..4]
            |]
         || x <- [0..4]
         |];
  };



piLookupIndex =
[[[0x0 0x0] [0x3 0x0] [0x1 0x0] [0x4 0x0] [0x2 0x0]]
 [[0x1 0x1] [0x4 0x1] [0x2 0x1] [0x0 0x1] [0x3 0x1]]
 [[0x2 0x2] [0x0 0x2] [0x3 0x2] [0x1 0x2] [0x4 0x2]]
 [[0x3 0x3] [0x1 0x3] [0x4 0x3] [0x2 0x3] [0x0 0x3]]
 [[0x4 0x4] [0x2 0x4] [0x0 0x4] [0x3 0x4] [0x1 0x4]]];

pi : [5][5][8][8];
pi (A) = A'
  where {
    S = [] # [| (A @ x @ y) 
             ||  [x y] <- join(piLookupIndex)
             |];
    A' = groupBy(5, S);
  };


/* Arithmetic in Cryptol is modulo the size of the word.
 * Here we need to explicitly make sure the cursors stay 
 * in range 
 */
chi : [5][5][8][8] -> [5][5][8][8];
chi (A) = [| [| (A @ x @ y) ^ 
               ((~(A @ ((x+1)%5) @ y )) & (A @ ((x+2)%5) @ y))
             || y <- [0..4]
             |]
          || x <- [0..4]
          |];



iota : ([5][5][8][8], [8]) -> [5][5][8][8];
iota (A, indexRound) = A'
  where {
     S  = repl(A@0, 0, (A@0@0) ^ 
                       splitBy(8,(KeccakRoundConstants@indexRound))) 
        # A @ 1
        # A @ 2
        # A @ 3
        # A @ 4;
     A' = groupBy(5, S);
  };

KeccakRound : ([5][5][8][8], [8]) -> [5][5][8][8];
KeccakRound(A, round) = iota(chi(pi(rho(thetaT(A)))), round);



KeccakAbsorb1024bits(S, Data) = KeccakPermutationAfterXor(S, take(16, Data));
KeccakAbsorb1088bits(S, Data) = KeccakPermutationAfterXor(S, take(17, Data));
KeccakAbsorb1152bits(S, Data) = KeccakPermutationAfterXor(S, take(18, Data));
KeccakAbsorb832bits(S, Data) = KeccakPermutationAfterXor(S, take(13, Data));
KeccakAbsorb576bits(S, Data) = KeccakPermutationAfterXor(S, take(9, Data));

/* laneCount parameter dropped, just run KeccakPermutationAfterXor
 * on all data and let the caller build a new list by dropping according
 * the current laneCount */
KeccakAbsorb : {a} (200 >= a, fin a) => ([200][8], [a][8]) -> [200][8];
KeccakAbsorb(S, Data) = KeccakPermutationAfterXor(S, Data);

KeccakPermutationAfterXor : {a} (200 >= a, fin a) => ([200][8], [a][8]) -> [200][8];
KeccakPermutationAfterXor(S, Data) = S''
  where {
        S'  = (take(width(Data), S) ^ Data) # drop(width(Data), S);
	S'' = KeccakPermutation(S');
        /* S'  = nextState(S, width(zero:[stateMsg]), join(A')); */
  };

KeccakExtract1024bits(S) = take(128, S);
KeccakExtract1088bits(S) = take(136, S);
KeccakExtract1152bits(S) = take(144, S);
KeccakExtract832bits(S) = take(104, S);
KeccakExtract576bits(S) = take(72, S);


KeccakPermutation(S) = S'
  where {
    A' = KeccakPermutationOnWords(groupBy(5, groupBy(8, S)));
    S' = join(join(A'));

  };

KeccakPermutationOnWords(A) = rounds @ 24
   where { 
     rounds = [A] # [| KeccakRound(state, roundnr) 
                    || state <- rounds
                    || roundnr <- [0..(nrRounds-1)]
                    |];
   };



type LFSRState =  {state : [9]; result : Bit};

LFSR86540 : [9] -> LFSRState;
LFSR86540(State) = if (State & 0x01 != 0) then ({state=State'; result=True }) 
                                          else ({state=State'; result=False} )
  where {
    State' = LFSR86540_Update(State);
  };

LFSR86540_Update(State) = if (State & 0x80 != 0) then (
      /* 
       * Cryptol support polynomial arithmetic over polynomial with 
       * binary coefficients. Keccak make use of a primitive
       * polynomial over GF(2). Here we specify the polynomial term 
       * inside <| |> brakets and mask the result with 0xff in order
       * to have a byte-wide state.
       */
      ((State << 1) ^ <| x^8 + x^6 + x^5 + x^4 + 1 |>) & 0xff
    ) else ( 
      State << 1
    );

KeccakInitializeState : [5][5][8][8];
KeccakInitializeState = [| [| splitBy(8, 0 : [64]) || y <- [0..4] |] || x <- [0..4] |];

KeccakInitializeRoundConstants : [24][64];
KeccakInitializeRoundConstants = Constants
  where {
    KeccakRoundConstants : [24][64];
    KeccakRoundConstants = splitBy(24, 0 : [1536]);

    W  = [ KeccakRoundConstants ] # 
         [| if ((state : LFSRState).result) then 
               repl(prev, i, (prev @ i) ^ (1<<((1<<j) - 1))) 
            else
               prev 
         || i <- [0..23],  j <- [0..6]
         || prev <- W
         || state <- iterateLFSR 0x01
         |];

    Constants = W @ 168;
  };

KeccakRoundConstants : [24][64];
KeccakRoundConstants = 
   [ 0x0000000000000001 
     0x0000000000008082 
     0x800000000000808a 
     0x8000000080008000
     0x000000000000808b 
     0x0000000080000001 
     0x8000000080008081 
     0x8000000000008009
     0x000000000000008a
     0x0000000000000088 
     0x0000000080008009 
     0x000000008000000a
     0x000000008000808b 
     0x800000000000008b 
     0x8000000000008089 
     0x8000000000008003
     0x8000000000008002 
     0x8000000000000080 
     0x000000000000800a 
     0x800000008000000a
     0x8000000080008081 
     0x8000000000008080 
     0x0000000080000001 
     0x8000000080008008 ];


KeccakInitializeRhoOffsets = O
  where {
     KeccakRhoOffsets : [25][64];
     KeccakRhoOffsets = [ 
          0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ];

     shiftOffsets = ts;

     shiftIndexes = iterateShiftIndex [[1] [0]];


     W = [ KeccakRhoOffsets ] # [| repl(prev, 5 * x + y, offset) 
                                ||    offset <- shiftOffsets
                                || [[x] [y]] <- shiftIndexes
                                ||      prev <- W
                                |];

     O = groupBy(5, W @ 24);
  };

KeccakRhoOffsets : [5][5][64];
KeccakRhoOffsets = [
[0x0000000000000000 0x0000000000000024 0x0000000000000003 0x0000000000000069 0x00000000000000d2]
 [0x0000000000000001 0x000000000000012c 0x000000000000000a 0x000000000000002d 0x0000000000000042]
 [0x00000000000000be 0x0000000000000006 0x00000000000000ab 0x000000000000000f 0x00000000000000fd]
 [0x000000000000001c 0x0000000000000037 0x0000000000000099 0x0000000000000015 0x0000000000000078]
 [0x000000000000005b 0x0000000000000114 0x00000000000000e7 0x0000000000000088 0x000000000000004e]];

